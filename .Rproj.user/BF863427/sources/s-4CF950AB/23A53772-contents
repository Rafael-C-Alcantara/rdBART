## Sufficient statistics
lambdaPosterior <- function(tree,W,X,m,sigma) {
  # priorInv <- solve(lambdaPrior)
  priorInv <- m*diag(ncol(X))
  XtX      <- by(X, fit(tree,W), FUN = function(x) as.matrix(t(x))%*%as.matrix(x)/sigma)
  return(mapply(function(x) solve(x+priorInv),XtX, SIMPLIFY = F))
}

thetaPosterior <- function(tree,W,X,y,lambdaPost,sigma) {
  # s        <- sigma
  # priorInv <- solve(lambdaPrior)
  Xty      <- by(cbind(y,X), fit(tree,W), FUN = function(x) as.matrix(t(x[,-1]))%*%as.matrix(x[,1])/sigma)
  # lt       <- priorInv%*%thetaPrior
  return(mapply(function(x,y) x%*%(y), lambdaPost, Xty, SIMPLIFY=F))
}

## Draws
### Draw theta for each bottom node
thetaDraw <- function(tree,W,X,y,sigma,m) {
  lambdaPost <- lambdaPosterior(tree,W,X,m,sigma)
  thetaPost  <- thetaPosterior(tree,W,X,y,lambdaPost,sigma)
  return(Map(function(x,y) MASS::mvrnorm(mu=as.vector(x),Sigma=y), thetaPost,lambdaPost))
}

### Vectorised version
thetaDrawVec <- function(list,W,X,y,sigma,m) {
  return(lapply(list, function(x) thetaDraw(x$tree,W,X,y,sigma,m)))
}

### Return matrix with parameter vector for each observation
### Will be used to sum over all trees later
yDraw <- function(tree,W,X,y,thetaDraw) {
  fit    <- fit(tree,W)
  output <- cbind(fit,y)
  nodes  <- as.numeric(names(thetaDraw))
  draw   <- matrix(unlist(thetaDraw,use.names = T),ncol=length(thetaDraw[[1]]),byrow = T)
  output <- merge(output,cbind(nodes,draw),by=1,sort=F)
  output <- output[order(match(output[,2],y)),]
  return(output[,-c(1:2)])
}

### Vectorised version
yDrawVec <- function(list,W,X,y,thetaDraws) {
  return(Reduce("+",Map(function(a,b) yDraw(a,W,X,y,b), lapply(list, function(x) x$tree), thetaDraws)))
}

## SQR for each node (will be used to draw sigma)
residNode <- function(tree,W,X,y,thetaDraw) {
  y1   <- by(y,fit(tree,W),function(x) x)
  X1   <- by(X,fit(tree,W),function(x) x)
  node <- as.numeric(names(thetaDraw))
  return(sum(mapply(function(y,x,d) t(y-as.matrix(x)%*%as.vector(d))%*%(y-as.matrix(x)%*%as.vector(d)), y1, X1, thetaDraw)))
}

### Vectorised version
residNodeVec <- function(list,W,X,y,thetaDraws) {
  return(Map(function(a,b) residNode(a,W,X,y,b), lapply(list, function(x) x$tree),thetaDraws))
}

## Predictions for y
yFit <- function(tree,W,X,thetaDraw) {
  X1   <- cbind(fit(tree,W),X)
  node <- as.numeric(names(thetaDraw))
  draw <- matrix(unlist(thetaDraw,use.names = T),ncol=length(thetaDraw[[1]]),byrow = T)
  output <- merge(X1,cbind(node,draw),by=1)
  output <- output[,2:((ncol(output)-1)/2+1)]*output[,((ncol(output)-1)/2+2):ncol(output)]
  yVec <- is.null(dim(output)) ## If dim(X)=1, dim(output)=NULL (it is a vector) and it already gives us what we want
  ifelse(yVec, return(output), return(rowSums(output)))
  
  # if (is.null(dim(output))) {
  #   ## If dim(X)=1, dim(output)=NULL (it is a vector) and it already gives us what we want
  #   return(output)
  # }
  # output <- apply(output,1,sum)
  # return(output)
}

### Vectorised version
yFitVec <- function(list,W,X,thetaDraws) {
  return(do.call("cbind",Map(function(a,b) yFit(a,W,X,b), lapply(list, function(x) x$tree), thetaDraws)))
}

## Draw new tree, obtain new parameter vector for that tree and return residual to be used
### in next tree
treeDraw <- function(treeInit,W,X,y,thetaPrior,m,sigma,alpha,beta) {
  ## Obtain new tree
  treeNew  <- proposal(treeInit,W)
  treeInit <- newTree(treeInit,treeNew,W,X,y,thetaPrior,m,sigma,alpha,beta)
  ## Obtain new parameter vector given tree
  draw  <- thetaDraw(treeInit,W,X,y,thetaPrior,sigma,m)
  draws <- yDraw(treeInit,W,X,y,draw) ## Matrix of the corresponding draw of each observation
  ## Obtain fit
  yhat <- yFit(treeInit,W,X,draw)
  ## Obtain sum of node sqr
  resNode <- residNode(treeInit,W,X,y,draw) 
  ## Return results
  return(list(tree=treeInit,drawBot=draw,draws=draws,yhat=yhat,resNode=resNode))
}

## Posterior for sigma
sigPost <- function(treeDraws,thetaDraws,X,y,m,nu,lambda) {
  # sumB   <- sum(unlist(lapply(treeDraws,function(x) nBottomNodes(x$tree))))
  n      <- nrow(X)
  # theta  <- Reduce("+",lapply(treeDraws, function(x) x$draws))
  sqr    <- Reduce("+",residNodeVec(treeDraws,W,X,y,thetaDraws))
  a      <- (nu+m*n)*0.5
  b      <- (nu*lambda + sqr)*0.5
  # print(c(sqr,t(K)%*%solve(lambdaPrior)%*%K))
  return(1/rgamma(1,shape=a,rate=b))
}
